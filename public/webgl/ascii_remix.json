{"history":[{"breakpoints":[],"aspectRatio":1,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"image","width":1620,"widthMode":1,"height":1620,"heightMode":2,"left":0.5,"top":0.5,"src":"https://assets.unicorn.studio/images/ofpWGfEQ0GYvb8ISPIfht8DJGvV2/68164b1a26ac9c1919e0c9be_pmc_icon%20(2)%20(1).png","imageNaturalSize":{"type":"Vec2","_x":256,"_y":256},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float absWidth = 1620.0000;\nfloat absHeight = 1620.0000 * uArtboardResolution.y;if (1 == 2) {\nabsWidth = absHeight * 1.0000;\n} else if (2 == 2) {\nabsHeight = absWidth / 1.0000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.5000, 0.5000) * uArtboardResolution - getAnchorOffsets() * elementSizePx;vec2 centerPos = elementPosPx + (elementSizePx * 0.5);\nvec2 relPos = canvasPos - centerPos + mouseOffset;\nvec2 unrotatedRelPos = rotate2D(relPos, 0.0000 * -TAU);\nvec2 elementPos = unrotatedRelPos + (elementSizePx * 0.5);\nimageUV = elementPos / elementSizePx;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(256, 256), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1}}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseFill","usesPingPong":false,"speed":0.25,"trackMouse":0.5,"trackAxes":"xy","mouseMomentum":0.15,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x <= 0.5) ? (1.0 - (1.0 - dst.x) / (2.0 * src.x)) : (dst.x / (2.0 * (1.0 - src.x))), (src.y <= 0.5) ? (1.0 - (1.0 - dst.y) / (2.0 * src.y)) : (dst.y / (2.0 * (1.0 - src.y))), (src.z <= 0.5) ? (1.0 - (1.0 - dst.z) / (2.0 * src.z)) : (dst.z / (2.0 * (1.0 - src.z))));\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;vec3 anchoredPal(float t, vec3 col1, vec3 col2) {\nvec3 mid = 0.5 * (col1 + col2);\nvec3 axisAmp = 0.5 * (col2 - col1);vec3 base = mid + axisAmp * cos(TAU * t);vec3 axis = length(axisAmp) > 0.0001 ? normalize(axisAmp) : vec3(1.0, 0.0, 0.0);\nvec3 ref = abs(axis.x) > 0.9 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\nvec3 tangent1 = normalize(cross(axis, ref));\nvec3 tangent2 = normalize(cross(axis, tangent1));float richness = 0.24 * length(axisAmp) + 0.02;\nvec3 ripple =\ntangent1 * sin(TAU * (t * 2.0 + 0.123)) +\ntangent2 * sin(TAU * (t * 3.0 + 0.437));vec3 col = base + (richness * 1.0000) * ripple;\ncol = clamp(col, -10.0, 10.0);\ncol = 1./(1. + exp(-col * 4. + 0.25) * 7.5);\nreturn clamp(col, 0.0, 1.0);\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float get2sNoise(vec2 uv) {\nfloat turb = 0.1500 * 2.;\nvec2 drift = vec2(0, 0.2500 * uTime * 0.008) * mix(1., 14., 0.6000);\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(0.5000, 1. - 0.5000) * 0.7 - drift, 0.0000 + uTime*0.02));\nreturn mix(0.5, noise.w * 0.5 + 0.5, turb);\n}float getNoise(vec2 uv) {\nreturn get2sNoise(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1.0);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.5000);vec2 pos = mix(vec2(0.5, 0.5), mPos, 0.5000);\nfloat scale = mix(1., 14., 0.6000);\nvec2 drift = vec2(0, 0.2500 * uTime * 0.0125);\nmat2 rotation = rot(0.0000 * 2. * PI);vec2 st = (uv - pos) * aspect * scale * rotation;\nfloat noise = getNoise(st);vec2 toMouse = (uv - uMousePos) * aspect;\nfloat r = length(toMouse);\nfloat radius = mix(0.1, 1., 0.5000);\nfloat falloff = 1.0 - smoothstep(0.0, radius, r);\nvec2 dir = toMouse / max(r, 1e-5);\nvec2 uvBulgeOffsetAspect = -dir * (0.1500 * radius) * falloff * falloff;\nvec2 offset = uvBulgeOffsetAspect / aspect * r * 5.;\nst = (uv - pos + offset * noise) * aspect * scale * rotation;\nnoise = getNoise(st);noise = smoothstep(noise - 0.5, noise + 0.5, 0.5000);vec4 color = texture(uTexture, uv);\nvec4 bg = color;\nfloat shift = 0.6800 + (0.0000 * uTime * 0.01);\nvec3 noiseColor = anchoredPal(noise + shift, vec3(0, 0.24313725490196078, 0.23137254901960785), vec3(0.788235294117647, 0.7176470588235294, 1));\ncolor.rgb = noiseColor.rgb;float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither * 0.5;color.rgb = blend(17, bg.rgb, color.rgb);color.rgb = mix(bg.rgb, color.rgb, 1.0000);\ncolor.a = max(bg.a, 1.0000);\ncolor = clamp(color, 0.0, 1.0);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"noise_fill"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,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","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.8040);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4800), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bloomFast","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nout vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}vec4 thresholdPass(vec4 color) {\ncolor.rgb = pow(color.rgb, vec3(1.0/2.2));\ncolor.rgb = 1.2 * (color.rgb - 0.5) + 0.5;\nvec4 bloom = color * smoothstep(0.5000 - 0.1, 0.5000, luma(color));\nreturn vec4(bloom.rgb, color.a);\n}vec4 getColor(vec4 color) {\nreturn thresholdPass(color);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);color = getColor(color);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;\nout vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 1.000000;\ncase 1: return 0.687719;\ncase 2: return 0.497017;\ncase 3: return 0.369784;\ncase 4: return 0.279890;\ncase 5: return 0.213571;\ncase 6: return 0.163045;\ncase 7: return 0.123612;\ncase 8: return 0.092212;\ncase 9: return 0.066840;\ncase 10: return 0.046045;\ncase 11: return 0.000000;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= (0.2 + 0.1800) * 2.5;\nfor (int i = 1; i <= 12; i++) {\nfloat weight = getGaussianWeight(i);\nfloat step = float(i)/16.;\nfloat offset = mix(0.015, 0.025, radius) * step;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nreturn blur(uv, vertical, radius, diamond);\n}vec4 getColor(vec4 color) {\nreturn blurPass(vTextureCoord, false, 7.5, 1., false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);color = getColor(color);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;\nout vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 1.000000;\ncase 1: return 0.687719;\ncase 2: return 0.497017;\ncase 3: return 0.369784;\ncase 4: return 0.279890;\ncase 5: return 0.213571;\ncase 6: return 0.163045;\ncase 7: return 0.123612;\ncase 8: return 0.092212;\ncase 9: return 0.066840;\ncase 10: return 0.046045;\ncase 11: return 0.000000;\ndefault: return 0.0;\n}\n}vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 dir;\nif (diamond) {\ndir = vertical ? vec2(1, 1) : vec2(1, -1);\n} else {\ndir = vertical ? vec2(0, 1) : vec2(1, 0);\n}\ndir.x /= aspectRatio;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;radius *= (0.2 + 0.1800) * 2.5;\nfor (int i = 1; i <= 12; i++) {\nfloat weight = getGaussianWeight(i);\nfloat step = float(i)/16.;\nfloat offset = mix(0.015, 0.025, radius) * step;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) {\nreturn blur(uv, vertical, radius, diamond);\n}vec4 getColor(vec4 color) {\nreturn blurPass(vTextureCoord, true, 7.5, 1., false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);color = getColor(color);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uniform vec2 uResolution;\nout vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec4 finalPass(vec4 bloomColor) {\nfloat nx = interleavedGradientNoise(vTextureCoord * uResolution);\nfloat ny = interleavedGradientNoise((vTextureCoord + vec2(16., 9.)) * uResolution);\nvec2 jitter = vec2(nx - 0.5, ny - 0.5) * 0.025 * (0.1800 + 0.1);\nbloomColor = texture(uTexture, vTextureCoord + jitter);\nbloomColor.rgb *= vec3(0.788235294117647, 0.7176470588235294, 1);\nvec4 sceneColor = texture(uBgTexture, vTextureCoord);\nvec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.7300 * 3.5);\nreturn finalColor;\n}vec4 getColor(vec4 color) {\nreturn finalPass(color);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);color = getColor(color);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"downSample":1,"includeBg":true}]},"id":"fast_bloom"}],"options":{"name":"ASCII (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.4","id":"iqmKJVFD9SyCutTNbiGK"}